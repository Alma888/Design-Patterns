怎样实现观察者模式编程

观察者模式又被称为监听者模式，它广泛的应用在图形化编程中，例如：当用户单机某个按钮的时候，应该做出什么响应；当商场打折的时候，应该通过E-mail和电话等形式通知消费者。本文在回答该问题的同时，详细地讲解观察者模式的原理和实现方式。


观察者模式的原理

观察者模式将观察者和被观察者的对象分离开。举例：当用户单击网页上的某个按钮时，网页做出一些反应行为，例如：弹出一个对话框，那么这个对话框是怎么知道用户是否点击了按钮呢？ 这是因为——>按钮被单击时，浏览器会通知所有观察这个按钮事件的观察者来做出反应。观察者模式在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。（好处）



Java 实现观察者模式的方式
观察者模式有很多实现方式，从根本上说，该模式必须包含两个关键角色：观察者和被观察者对象。  在上述的例子中，按钮是被观察对象，弹出对话框是观察者。观察者和被观察者之间存在 “观察” 的逻辑关联，当被观察者发生改变的时候，观察者就会观察到这样的变化，并且做出相应的响应。

     “ 观察 ” 不是“ 直接调用 ”。实现观察者模式的时候要注意，观察者和被观察者对象之
间的互动关系不能体现成类之间的直接调用，否则就将使观察者和被观察者对象之间紧密的耦合
起来，从根本上违反面向对象的设计原则。无论是观察者 “ 观察 ” 观察对象，还是被观察者
将自己的改变 “ 通知 ” 观察者，都不应该直接调用。

      应该通过一种注册和回调 的形式来实现观察者模式。观察者往往是需要实现某个接口的，被观察者保存着这些被注册的观察者的信息（用List、Set等集合对象保存这些观察者对象），一旦发生变化则通过 多态 回调 观察者的接口方法，从而达到低耦合的目的。

      实现观察者模式有很多形式，比较直观的一种是使用  " 注册、通知、撤销注册"  的形式，大致过程如下：
    （1）观察者（Observer） 将自己注册到被观察对象（Subject）中去，被观察对象将观察者存放在一个容器（Container）中。


     技巧—为了防止重复注册观察者，一般采用 HashSet 来保存观察者的引用—

       观察者们需要实现某一个接口或继承自某个抽象类，便于被观察者统一对待且可以调用某个方法，以便做出响应，例如下面的代码：

       interface Observer {  //观察者接口
           public void update(Product p);  //价格修改的接口方法
           public void unreg(Product p);   //撤销注册
       }

       class WebObserver implements Observer { //Web 观察者
           @Override
           public void update(Product p) {           //定义回调方法
               System.out.println("更新页面价格："+p.getName()+":"+p.getPrice());
           }
       }

       class MailObserver implements Observer { //Mail 观察者

           @Override
           public void update(Product p) {      //定义回调方法

               System.out.println("为所有会员发送价格变化信息："+
                       p.getName()+":"+p.getPrice());
           }
       }

       class Product{                        //被观察者
           private HashSet<Observer> observers;  //保存所有的观察者
           //...
       }

         （2）被观察对象发生了某种变化（如按钮被单击、商品价格发生变化等），从容器中得到所有注册过的观察者，将变化通知观察者。在代码中，需要做的就是遍历容器中的观察者，调用它们的回调方法，具体代码如下：
       //通知监听者（观察者）执行update()方法
       public void notifyObserver(){
           for(Observer ob:observers){
               ob.update(this);   //回调所有观察者的观察方法
           }
       }


       注意：以上的代码是直接回调的，其实如果为了更高的性能和效率，可以另开一个线程来回调，这样可以不影响被观察者的其他行为。

        （3） 观察者告诉被观察者要撤销观察，被观察者从容器中将观察者去除。
                  为了需要支持撤销观察（或称为取消注册），在观察者接口方法中还需要多一个方法（unreg()），用于撤销观察。在该方法体中，需要做的就是得到被观察者的容器，然后去掉当前的观察者，代码如下：
       interface Observer {  //观察者接口
           public void unreg(Product p);   //撤销注册
       }

       class WebObserver implements Observer { //Web 观察者
           @Override
           public void unreg(Product p) {
              p.getObservers().remove(this);   //去掉本观察者
           }
       }

       class MailObserver implements Observer { //Mail 观察者

           @Override
           public void unreg(Product p) {
              p.getObservers().remove(this);   //去掉本观察者
           }
       }


       以上代码中，设定了两个观察者，商品发生了两次价格变化。第一次价格变化时，
       两个观察者都做出了响应；第二次价格变化时，只有观察者2在进行观察。因此，
       示例代码的运行结果如下：

       ===第1次价格变动===
       为所有会员发送价格变化信息：《Java核心技术》:80.0
       更新页面价格：《Java核心技术》:80.0
       ===第2次价格变动===
       为所有会员发送价格变化信息：《Java核心技术》:100.0


