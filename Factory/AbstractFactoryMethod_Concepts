如果抽象角色不止一个的时候，也就是工厂需要造出多种产品（这些产品是有联系的）的时候，简单工厂模式和工厂方法模式就不太应付得了。此时，就需要使用抽象工厂方法模式了，它就是为了专门应对多种抽象产品而设计的。本例在回答该问题的同时，详细的讲解抽象工厂方法模式的原理和实现方式。

抽象工厂方法模式的原理

使用简单工厂类，需要在工厂类里做逻辑判断。而工厂类虽然不用在工厂类做判断。但是带来了另一种耦合：客户端代码与不同的工厂类耦合。

为了解决客户端代码与不同工厂类耦合的问题。在工厂类的基础上再增加一个工厂类，该工厂类不制造具体的被调用对象，而是制造不同工厂对象——抽象工厂方法模式

      所谓抽象工厂模式就是她提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。他允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。这样一来，客户就可以从具体的产品中被解耦。它的优点是隔离了具体类的生成，使得客户端不需要知道什么被创建了，而缺点就在于新增新的行为会比较麻烦，因为当添加一个新的产品对象时，需要更改接口及其下所有子类。其UML结构图如下：



【抽象工厂方法模式的参与者】（和工厂方法的如出一辙）：
     抽象工厂角色：这是工厂方法模式的核心，它与应用程序无关。抽象工厂定
 AbstractFactory义了一个接口，它是具体工厂角色必须实现的接口 或者 必
                             须继承的父类。这个接口包含了一组方法用来生产产品。在
                              java中它由抽象类来实现。（AbstractAutoFactory抽象类）

    具体工厂角色：它含有和具体业务逻辑有关的代码。具体工厂是用于生产不ConcreteFactory同产品族。要创建一个产品，客户只需要使用其中一个工厂
                       完全不需要实例化任何产品对象。（代码中的CarFactory
                                                                     和TruckFactory）

    抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般
AbstractProduct 有抽象类或者接口来实现。（车类：abstract class Auto
                                                                         零件类：abstract class Wheel）

    具体产品角色： 具体工厂角色所创建的对象就是此角色的实例。在java中由
     Product            具体的类来实现。（车类和零件类的子类）




Java实现抽象工厂方法模式的方式
可以这样理解：工厂方法模式针对的是一个产品等级结构；
                         而抽象工厂方法模式针对的是多个产品等级结构。

例如：一个抽象的汽车工厂可以生产汽车及其配套的轮子，它的子类工厂是轿车工厂和卡车工厂，轿车工厂生产轿车和轿车轮子，卡车工厂生产卡车和卡车轮子，示例代码如下：
//可以创造一个轮胎接口
interface CreateWheelAble{
    public abstract Wheel createWheel();
}
//抽象汽车工厂
abstract class AbstractAutoFactory1 implements CreateWheelAble{
    public abstract Auto createAuto();        //创造一个汽车的抽象方法
    @Override
    public abstract Wheel createWheel();      //创造一个轮胎的抽象方法
}
//轿车工厂
class CarFactory2 extends AbstractAutoFactory1{
    @Override
    public Auto createAuto() {
        return new Car();                    //返回的是轿车
    }
    @Override
    public Wheel createWheel() {
        return new CarWheel();               //返回的是轿车轮胎
    }
}
//卡车工厂
class TruckFactory2 extends AbstractAutoFactory1{
    @Override
    public Auto createAuto() {
        return new Truck();                //返回的是卡车
    }

    @Override
    public Wheel createWheel() {
        return new TruckWheel();          //返回的是卡车轮胎
    }
}


由于每个具体工厂角色都需要实现以上两个工厂方法（造 车和轮子），所以具有一般性，不妨抽象出来，移动到抽象工厂角色加以声明，例如，以上代码中的CreateWheelAble 接口中的createWheel()方法。
（这里就用到了多态的特性，提高了代码的扩展性）

说明：在实际开发中，抽象工厂往往还会实现多个接口，例如：生成汽车玻璃、刹车、油箱等。


——————————————————————————————————
     * 抽象工厂模式的意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指
                                            定它们具体的类。
     * 抽象工厂模式的实现技巧：
                          1、将抽象工厂建产品对象的创建延迟到它的具体工厂子类。
     *                    2、如果没有应对“多系列对象的”需求变化，则没有必要使用抽象工厂，
                                 这是使用简单的静态工厂就可以胜任了。
     *                    3、系列对象指的是这些对象之间相互依赖或相互作用的关系，例如游
                                戏场景开发中道路与房屋的依赖，道路与地道的依赖
     *                    4、抽象工厂模式经常和工厂方法模式共同组合来应对“对象创建”的需求
                                变化，即用工厂方法模式来创建单个产品，而用抽象工厂模式创建
                                 产品族
     *                    5、通常在运行时刻创建一个具体工厂的实例，这一具体工厂的创建具
                                体有特定实现的产品对象，为创建不同的产品对象，客户应使用不
                                同的具体工厂。
     *                    6、把工厂做为单件时，一个应用中一般每个产品系列只需要一个工厂
                                 实例，因此工厂通常最好实现一个单件模式。
     *                    7、创建产品，抽象工厂仅声明一个创建产品的接口，真正出创建产品
                                的是由具体产品类创建的，通常的办法是为每一个产品定义一个工
                                厂方法，一个具体的工厂将为每个产品重定义该工厂方法以指定产
                                品，虽然这样的实现很简单，但它却要求每个产品系列都有一个具
                                体的工厂子类，即使这些产品系列的差别很小。


     * 抽象工厂模式的优点：
                          1、分离了具体的类，抽象向工厂模式帮助你控制一个应用创建对象的
                                类，因为工厂封装了创建产品对象的责任和过程，将客户和类的实
                                现分离，客户通过他们的抽象接口操纵实例，产品的类名也在具体
                                工厂的实现中被分离，他们不出现在客户代码中。
     *                   2、抽象工厂模式使得易于交换产品系列，一个具体的工程类在一个应用
                                中仅出现一次，即在它初始化的时候，这使得改变一个应用的具体
                               的工厂变得容易，只需要改变具体工厂即可使用不同的产品配置，因
                               为一个抽象工厂创建了一个完整系列，属于整个产品系列会立刻改
                               变。（即产品族的约束为非公开状态）
     *                   3、它有利于产品的一致性，当一个系列的产品对象被设计成一起工作
                               时，一个应用一次只能使用同一个系列中的对象，因为这在实际应用
                               中经常遇到，而抽象工厂则非常容易实现这点。
     *
     * 抽象工厂模式缺点：
                         1、难以支持新种类的产品。难以扩展抽象工厂以生产新种类的产品。这
                              是因为抽象工厂几乎确定了可以被创建的产品集合， 支持新种类的产
                            品就需要扩展该工厂接口，这将涉及抽象工厂类及其所有子类的改变。
     *抽象工厂模式的场景：
                          当有多个抽象角色时，使用该模式。